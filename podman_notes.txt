# Podman Lab 
podman images 									# View container images available
podman run -it rhel8-httpd /bin/bash						# Deploy container in an interactive fashion 
										# -it means interactive
df -hP 										# Take a look at the mounted file system 
										# overlay is associated with the runtime of the container image
										# tmpfs and shm are memory-based filesystem contents
podman ps -a									# Verify container is running. 
										# Ea container is assinged a unique ID and Name
podman rm $(podman ps -a | grep Exited | cut -d" " -f1)				# To remove a container from the system, use podman rm
podman ps -a									# Running this you can confirm STATUS is Exited
										# Command uses bash scripting to determine the CONTAINER ID 
										# Output is the full CONTAINTER ID that was removed from the system
podman run -dt -p 8081:80/tcp rhel8-httpd					# Create new instance of the rhel8-httpd container in detachted mode
										# Command also configured port forwarding for the Apache web server
										# The host's port 8081 will redirect to the running container's port 80
podman ps -a									# Running this command shows STATUS is Up 
										# The PORTS section shows port forwarding defined for the container
podman stop $(podman ps -a | grep Up | cut -d" " -f1)				# Interactive containers are stopped using podman stop
podman ps -a									# Running this you can confirm STATUS is Exited




# Containerize an App Lab
buildah from registry.access.redhat.com/ubi8/ubi				# Download the Standard UBI image from Red Hat's Registry
										# Image was successfully downloaded 
										# Container image was created and attached to the system 
 										# Name is ubi-working-container
buildah run ubi-working-container -- yum -y install \				# buildah is going to run a command on the ubi-working-container image
https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm  	# The -- exexutes the command from within the container	
										# install a package that defines all of the repositories from EPEL
rpm -q epel-release								# Verify this was not completed on the host
										# Looks for RPM on the host system 
buildah run ubi-working-container -- yum -y install moon-buggy			# Install software in the container
podman run -it moon-buggy /usr/bin/moon-buggy					# Run container in interactive mode based on image
										# The command run interactively will be /usr/bin/moon-buggy
podman kill $(podman ps | grep -v CONTAINER | cut -f1 -d" " )			# Kill the running container from another terminal

buildah commit ubi-working-container moon-buggy					# Commit the working container to an image called: moon-buggy
podman image list								# Verify by looking at the available container images on the system




# Buildah Lab Part 1
buildah from registry.access.redhat.com/ubi8/ubi-init				# To build an application container from the ubi-init base image,
									  	  create a working container with buildah
										# A working container is a temp container used as the target for buildah commands
										# The ubi-init image includes tools like yum and systemd
buildah run ubi-init-working-container -- yum -y install httpd			# Install httpd via yum in the container using the buildah run 
										# This subcommand acts like the RUN directive in an Containerfile
										# Use the -- syntax to tell buildah run there are no buildah 
									  	  options to look for past this point.
buildah run ubi-init-working-container -- systemctl enable httpd		# Enable httpd to start when the container is run via systemd 
									  	  using the buildah run subcommand
buildah copy ubi-init-working-container index1.html /var/www/html/index.html	# Deploy web content to the container image with buildah copy 
										# This subcommand acts like the COPY directive in a Containerfile
buildah config --port 80 --cmd "/usr/sbin/init" ubi-init-working-container	# Expose the web server port and set systemd to start when the container is 											          run and modify the metadata
										# These options to buildah config are equivalent to the EXPOSE and CMD 										  			  directives in a Containerfile
buildah commit ubi-init-working-container el-httpd1				# Save the working container as the target app image using buildah commit
podman images									# Inspect the images available on the host
podman run -d -p 80:80 el-httpd1						# Podman and buildah use the same storage locations on the host, which lets us
										  immediately run the image we just built via podman
podman ps									# Check the status of the application container
buildah inspect localhost/el-httpd1						# Inspect the image metadata for the application container 
podman stop -a									# Stop all running containers




# Buildah Lab Part 2
buildah from scratch								# Buildah can create a minimal container image that contains metadata and a 
										  filesystem stub. 		
										# Since there's no starting image, the working container will be called 
										  working-container
scratchmnt=$(buildah mount working-container)					# We can start working with the scratch container using tools on the host by		
echo ${scratchmnt}								  mounting the container filesystem on the host
ls -l ${scratchmnt}								# Directory is empty 
yum install --installroot ${scratchmnt} httpd --releasever 8 			# In order to install httpd in the scratch container, use yum on the host with the
--setopt=module_platform_id="platform:el8" -y					  installroot option targeting the mount point of the container's filesystem. 
										# Many more packages required than using the base image, but we have httpd and 
										  systemd but not other tools like yum.
chroot ${scratchmnt} systemctl enable httpd					# To enable httpd to start when the container is run using systemd, we can use 
										  the container mount point like a normal chroot.
cp index2.html ${scratchmnt}/var/www/html/index.html				# Deploying web content to the container image can be done using a cp command 
										  on the host to the working container mount point
buildah unmount working-container						# After installing packages and adding the index file, unmount the filesystem 
buildah config --port 80 --cmd "/usr/sbin/init" working-container		# expose the web server port and set systemd to start when the container is run
buildah commit working-container el-httpd2					# Save the working container as the target application image 
										# all operations were done directly to the container filesystem, 
										  resulting in a single layer
										# The buildah commit step can be run at any point where a layer is needed, 
										  for example to cache a common set of packages across multiple applications.
podman images									# Inspect the images available on the host
podman run -d -p 80:80 el-httpd2						# Podman and buildah use the same storage locations on the host, which lets us
										  immediately run the image we just built via podman
podman ps									# Check the status of the application container
buildah inspect localhost/el-httpd2						# Inspect the image metadata for the application container 
										# Look for the rootfs section in the JSON output. 
										  You will see the single layer created


# Fish sticks



